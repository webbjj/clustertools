.. _cluster:
StarCluster
===============

The ``StarCluster`` class is the foundation on which ''clustertools'' has been built. All functions have been designed to either act on or use elements of `StarCluster``. Its purpose is to be a python representation of a star cluster, based on either a snapshot provided by a simulation or a distribution function. At minimum, a ``StarCluster`` contains the positions and velocities of all stars in a star cluster. However, ``StarCluster`` has been designed to store all information related to the cluster's orbit, Single Star Evolution, Binary Star Evolution, and metadata related to the software used to generate the data and/or the data file it was read from. Once initiated, ``clustertools`` is able to perform a large number of operations, measurements, and calculations on the ``StarCluster`` class. 

To initialize a ``StarCluster``, one can simply start with:

>>> import clustertools

>>> cluster=StarCluster()

``StarCluster`` accepts additional optional arguments, each of which have defaults. They are the current time (``tphys=0``), the units (``units=None``) and origin (``origin=None``) of the coordinate systemm and the name of the code used to genereate the dataset ``ctype``. The units and origin variables only need to be specified if unit or coordinate trannsformations are going to be done (see :ref:`Units and Coordinate Systems <units_and_coordinate_systems>` for more information). The code type ``ctype`` defaults to ``'snapshot'``, but can be set to ``'nbody6'``,``'nbody6se'``,``'gyrfalcon'``, or ``'amuse'``, or ``'clustertools'`` for reading in snapshots generated by ``clustertools``. ``ctype`` informs the ``StarCluster`` of the input files format. See :ref:`Load or Setup <load_or_setup>` for more informatoin on how ``ctype`` is used. Other keywords accepted when initializing a ``StarCluster`` can be found in the complete documentation (see StarCluster).

Once a ``StarCluster`` is initialized, there are a large number of arrays and variables that correspond to individual stars, global properties of the cluster, and information related to the software used to generate the data (see SOMEWHERE for the complete list). However, several functions have then been written to more easily populate ``StarCluster`` with information and carry out helpful calculations. They are:

* add_stars
* add_orbit
* add_nbody6
* add_sse
* add_bse
* add_energies
* add_actions
* rv3d
* key_params

.. automodapi:: clustertools.analysis.cluster
        :no-inheritance-diagram:

The ``add_stars`` function is the intended way to actually add stars to ``cluster``. Assuming stellar positions (x,y,z) and velocities (vx,vy,vz) have already been read in via a snapshot, one can call:

>>> cluster.add_stars(x,y,z,vx,vy,vz,do_key_params=True,do_order=True)

Using ``add_stars`` as opposed to setting variables like ``cluster.x`` mantually ensures that ``cluster.rv3d`` is automatically called and the three dimensional radius (``cluster.r``) and velocity (``cluster.v``) of each star is calculated. By default, projected radii (``cluster.rpro``) and velocities (``cluster.vpro``) are also calculated assuming the x-y plane is the plane of the sky. However this option can be turned off via ``cluster.projected=False`` or using the keyword ``projected=False`` when initializing the ``StarCluster``.

It is also possible to include stellar masses ``m`` and ids ``id`` if they are known via: 

>>> cluster.add_stars(x,y,z,vx,vy,vz,m,id,do_key_params=True,do_order=True)

Otherwise, masses will be set to 1 and ids will simply be set to integer values between 1 and the number of stars in the cluster.

Finally, using ``add_stars`` results in ``cluster.ntot`` being recalculated. Hence if the total number of stars is not initially known when ``StarCluster`` is first initialized, or perhaps changes, ``cluster.ntot`` is adjusted accordingly.

Two other features in ``add_stars`` that are by default set to ``False`` are ``do_order`` and ``do_key_params`` for computational efficiency. Setting ``do_key_params=True`` will cause the total mass ``cluster.mtot``, mean mass ``cluster.mmean``, mean radius ``cluster.meanr``, and maximum radius ``cluster.rmax`` to be calculated. If ``do_order=True``, then stars will be sorted based on their distance from the origin (information stored in ``cluster.rorder``) and the half-mass radius ``rm`` and 10\% Lagrange radius ``r10`` will be calculated as well. Alternatively, one can call:

>>> cluster.key_params(do_order=True)

at a later point in time. 

If the cluster's galactocentric positiion (xgc,ygc,zgc) and velocity (vxgc,vygc,vzgc) are known, then orbital information can be added via:

>>> cluster.add_orbit(xgc,ygc,zgc,vxgc,vygc,vzgc)

It is beneficial to use ``add_orbit`` as opposed to setting variables like ``cluster.xgc`` manually is reflected in the additional arguments that can be passed. These arguments, and their default values, include ``ounits=None``, ``initialize=False``, ``ro=8.``, and ``vo=220.``. ``ounits`` informs ``StarCluster`` of the units of the galactocentric coordinates that are being provided. If they differ from ``cluster.units``, the unit conversion will be handled internally. ``intialize`` is an example of how strongly ``clustertools`` relies on ``galpy``, for if ``intialize=True`` a ``galpy`` orbit is initialized using the galactocentric coordinates provided and both ro (distance from vantage point to the cluster (kpc)) and vo (the circular velocity at ro (km/s)). The ``galpy`` orbit can be accessed via ``cluster.orbit``.

``add_nbody6``, ``add_sse``, and ``add_bse`` are tailored to the standard output from ``NBODY6`` (REFERENCE). They are simple functions of convenience for adding information that ``NBODY6`` provides regarding the simulations itself, single star evolution, and binary star evolution. They would be called via:

>>> cluster.add_nbody6(nc, rc, rbar, rtide, xc, yc, zc, zmbar, vstar, rscale, nsbnd, nbbnd)
>>> cluster.add_sse(kw, logl, logr, ep, ospin)
>>> cluster.add_bse(id1,id2,kw1,kw2,kcm,ecc,pb,semi,m1,m2,logl1,logl2,logr1,logr2,ep1,ep2,ospin1,ospin2)

For those not familiar with ``NBODY6``, please consult the documention for ``add_nbody6``, ``add_sse``, and ``add_bse`` for the defintion of each variable. It is important to note that each of the above variables are intialized with upon the initialization of ``StarCluster``, hence they can be set manually as well if you are using a code other than ``NBODY6`` and would like to define some of these parameters. Note, no units or origin are associated with any of the values provided via ``add_nbody6``, ``add_sse``, and ``add_bse`` such that they are not adjusted when unit and coordinate transformations are performed. 

One variable that is worth expanding on is the ``kw`` parameter. Motivated by NBODY6, each star's stellar evolution type is described by ``kw``. The below table illustrates what each ``kw`` integer represents. If you need to quickly lookup this table, it can be printed to screen using the function ``kwtypes()`` (See :ref:`Utilities <utilities>`).

.. list-table:: Table 1 - Relationship between ``kw`` and stellar evolution type, as per NBODY6
   :widths: 25 25
   :header-rows: 1

   * - KW
     - Stellar Evolution Types
   * - 0 
     - Low main sequence (M < 0.7).
   * - 1
     - Main sequence.
   * - 2
     - Hertzsprung gap (HG).
   * - 3
     - Red giant.
   * - 4
     - Core Helium burning.
   * - 5
     - First AGB.
   * - 6
     - Second AGB.
   * - 7
     - Helium main sequence.
   * - 8
     - Helium HG.
   * - 9
     - Helium GB.
   * - 10
     - Helium white dwarf.
   * - 11
     - Carbon-Oxygen white dwarf.
   * - 12
     - Oxygen-Neon white dwarf.
   * - 13
     - Neutron star.
   * - 14
     - Black hole.
   * - 15
     - Massless supernova remnant.

It is important to note that if stellar luminosities (``logl``) have been provided, calling ``cluster.key_params`` will also calculate the half-light radius of the cluster ``cluster.rh`` and the radius containing 10% of the light ``cluster.rh10``. Similar to ``cluster.rv3d``, by default the projected half-light radius ``cluster.rhpro`` and the projected radius containing 10% of the light ``cluster.rh10pro`` are calculated as well.

``add_energies`` is slightly more than a convenience function, because if the kinetic energy (kin), potential energy (pot), and total energy (etot) of each star added to ``StarCluster`` via:

>>> cluster.add_energies(kin, pot, etot)

then the total kinetic energy (``cluster.ektot``) and total potential energy (``cluster.ptot``) are calculated. Additional, the virial parameter Qvir is also calcualted and can be accessed via ``cluster.qvir``. 

Orbit actions must be added via ``add_actions`` because the associated variables are not created when a ``StarCluster`` is initialized. Hence once the actions JR, Jphi, and Jz have been calculated they can be added to the cluster via:

>>> cluster.add_actions(JR, Jphi, Jz)

Note that it is also possible to add orbital frequencies and periods by using:

>>> cluster.add_actions(JR, Jphi, Jz, OR, Ophi, Oz, TR, Tphi, Tz)


Finally, it is also possible within ``clustertools`` to extract a subset of stars from a ``StarCluster`` to form a new ``StarCluster`` using the ``sub_cluster`` function. For example, to extrct only stars within the cluster's half-mass radius one can call:

>>> new_cluster=ctools.sub_cluster(cluster,rmin=0,rmax=cluster.rm)

In this example, ``new_cluster`` will contain all the same information as ``cluster`` but only for stars within ``cluster.rm``. Please consult the ``sub_cluster`` documentation for the complete list of criteria that can be given to ``sub_cluster``.
